package missions;

import configuration.EnemyConfiguration;
import configuration.ItemConfiguration;
import configuration.MobConfiguration;
import configuration.NoSuchElementInConfigurationException;
import elements.Enemy;
import elements.Item;
import elements.NullAnimationException;
import org.newdawn.slick.SlickException;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MissionManager extends Mission {

    private Set<Enemy> enemies;
    private Set<Item> items;
    private Set<Mission> missions;
    private EnemyConfiguration mobConf;
    private ItemConfiguration itemConf;

    public MissionManager(EnemyConfiguration mobConf, ItemConfiguration itemConf){
        this.mobConf = mobConf;
        this.itemConf = itemConf;
        this.missions = new HashSet<>();
    }

    /**
     * Adds a mission to the list
     *
     * @param e the mission to add
     * @return true if the mission was added, false otherwise
     */
    @Override
    public boolean add(Mission e) {
        return missions.add(e);
    }

    /**
     * @return the number of missions in the component
     */
    @Override
    public int numMissions() {
        return missions.size();
    }

    /**
     * @return true if the mission was completed, false otherwise
     */
    @Override
    public boolean completed() {
        boolean flag = true;
        for(Mission m : missions){
            flag = flag && m.completed();
        }
        return flag;
    }

    /**
     * Check if an item contributes to a mission
     *
     * @param item the item to check
     */
    @Override
    public void check(MissionItem item) {
        for(Mission m : missions){
            m.check(item);
        }
    }

    /**
     * @return the item set generated by the mission
     */
    @Override
    public Set<Item> getItemSet() {
        if(items == null){
            try {
                buildItemSet();
            } catch (NullAnimationException | SlickException | NoSuchElementInConfigurationException e) {
                e.printStackTrace();
            }
        }
        return items;
    }

    /**
     * @return the mob set generated by the mission
     */
    @Override
    public Set<Enemy> getEnemySet() {
        if(enemies == null){
            try {
                buildEnemySet();
            } catch (NullAnimationException | NoSuchElementInConfigurationException | SlickException e) {
                e.printStackTrace();
            }
        }
        return enemies;
    }

    /**
     * Build the minimal item set for this set of missions
     */
    private void buildItemSet() throws NullAnimationException, SlickException, NoSuchElementInConfigurationException {
        //Gets all the mission specific items
        Set<Item> primer = new HashSet<>();
        for(Mission m : missions) {
            if (m.getItemSet() != null) {
                primer.addAll(m.getItemSet());
            }
        }

        //Gets all the general items
        Map<String, Integer> generals = new HashMap<>();
        for(Mission m : missions){
            for(Map.Entry<String, Integer> e : m.getItemPopulation().entrySet()){
                addToGeneralMap(generals, e);
            }
        }

        //If there are some specific items that can be used also as general, remove one of them from the generals
        for(Item i : primer){
            removeFromGeneralMap(generals, i);
        }

        //Generate the remaining items
        for(Map.Entry<String, Integer> e : generals.entrySet()){
            for(int i=0; i<e.getValue(); i++){
                primer.add(new Item(itemConf, e.getKey()));
            }
        }

        this.items = primer;
    }

    /**
     * Build the minimal item set for this set of missions
     */
    private void buildEnemySet() throws NullAnimationException, NoSuchElementInConfigurationException, SlickException {
        //Gets all the mission specific items
        Set<Enemy> primer = new HashSet<>();
        for(Mission m : missions){
            if(m.getEnemySet() != null) {
                primer.addAll(m.getEnemySet());
            }
        }

        //Gets all the general items
        Map<String, Integer> generals = new HashMap<>();
        for(Mission m : missions){
            for(Map.Entry<String, Integer> e : m.getEnemyPopulation().entrySet()){
                addToGeneralMap(generals, e);
            }
        }

        //If there are some specific items that can be used also as general, remove one of them from the generals
        for(Enemy i : primer){
            removeFromGeneralMap(generals, i);
        }

        //Generate the remaining items
        for(Map.Entry<String, Integer> e : generals.entrySet()){
            for(int i=0; i<e.getValue(); i++){
                primer.add(new Enemy(mobConf, e.getKey()));
            }
        }

        this.enemies = primer;
    }

    private void addToGeneralMap(Map<String, Integer> generals, Map.Entry<String, Integer> e){
        Integer qty = generals.get(e.getKey());
        if(qty == null || qty < e.getValue()){
            generals.put(e.getKey(), e.getValue());
        }
    }

    private void removeFromGeneralMap(Map<String, Integer> generals, MissionItem i){
        String ID = i.getID();
        Integer value = generals.get(ID);
        if(value != null){
            generals.put(ID, value-1);
        }
    }

    @Override
    public String toString(){
        String ret = "";
        for(Mission m : missions){
            ret += m.toString() + "\n";
        }
        return ret;
    }

    /**
     * @return the number of interactions needed to complete the mission
     */
    @Override
    public int getNumInteractions() {
        int sum = 0;
        for(Mission m : missions){
            sum += m.getNumInteractions();
        }
        return sum;
    }
}
